.\"     Title: git-rerere
.\"    Author: 
.\" Generator: DocBook XSL Stylesheets v1.73.2 <http://docbook.sf.net/>
.\"      Date: 10/31/2008
.\"    Manual: Git Manual
.\"    Source: Git 1.6.0.2.287.g3791f
.\"
.TH "GIT\-RERERE" "1" "10/31/2008" "Git 1\.6\.0\.2\.287\.g3791f" "Git Manual"
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.SH "NAME"
git-rerere - Reuse recorded resolution of conflicted merges
.SH "SYNOPSIS"
\fIgit rerere\fR [\fIclear\fR|\fIdiff\fR|\fIstatus\fR|\fIgc\fR]
.SH "DESCRIPTION"
In a workflow that employs relatively long lived topic branches, the developer sometimes needs to resolve the same conflict over and over again until the topic branches are done (either merged to the "release" branch, or sent out and accepted upstream)\.

This command helps this process by recording conflicted automerge results and corresponding hand\-resolve results on the initial manual merge, and later by noticing the same automerge results and applying the previously recorded hand resolution\.
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
Note
You need to set the configuration variable rerere\.enabled to enable this command\.

.SH "COMMANDS"
Normally, \fIgit\-rerere\fR is run without arguments or user\-intervention\. However, it has several commands that allow it to interact with its working state\.
.PP
\fIclear\fR
.RS 4
This resets the metadata used by rerere if a merge resolution is to be aborted\. Calling \fIgit\-am [\-\-skip|\-\-abort]\fR or \fIgit\-rebase [\-\-skip|\-\-abort]\fR will automatically invoke this command\.
.RE
.PP
\fIdiff\fR
.RS 4
This displays diffs for the current state of the resolution\. It is useful for tracking what has changed while the user is resolving conflicts\. Additional arguments are passed directly to the system \fIdiff\fR command installed in PATH\.
.RE
.PP
\fIstatus\fR
.RS 4
Like \fIdiff\fR, but this only prints the filenames that will be tracked for resolutions\.
.RE
.PP
\fIgc\fR
.RS 4
This command is used to prune records of conflicted merge that occurred long time ago\. By default, conflicts older than 15 days that you have not recorded their resolution, and conflicts older than 60 days, are pruned\. These are controlled with gc\.rerereunresolved and gc\.rerereresolved configuration variables\.
.RE
.SH "DISCUSSION"
When your topic branch modifies overlapping area that your master branch (or upstream) touched since your topic branch forked from it, you may want to test it with the latest master, even before your topic branch is ready to be pushed upstream:

.sp
.RS 4
.nf

\.ft C
              o\-\-\-*\-\-\-o topic
             /
    o\-\-\-o\-\-\-o\-\-\-*\-\-\-o\-\-\-o master
\.ft

.fi
.RE
For such a test, you need to merge master and topic somehow\. One way to do it is to pull master into the topic branch:

.sp
.RS 4
.nf

\.ft C
        $ git checkout topic
        $ git merge master

              o\-\-\-*\-\-\-o\-\-\-+ topic
             /           /
    o\-\-\-o\-\-\-o\-\-\-*\-\-\-o\-\-\-o master
\.ft

.fi
.RE
The commits marked with * touch the same area in the same file; you need to resolve the conflicts when creating the commit marked with +\. Then you can test the result to make sure your work\-in\-progress still works with what is in the latest master\.

After this test merge, there are two ways to continue your work on the topic\. The easiest is to build on top of the test merge commit +, and when your work in the topic branch is finally ready, pull the topic branch into master, and/or ask the upstream to pull from you\. By that time, however, the master or the upstream might have been advanced since the test merge +, in which case the final commit graph would look like this:

.sp
.RS 4
.nf

\.ft C
        $ git checkout topic
        $ git merge master
        $ \.\.\. work on both topic and master branches
        $ git checkout master
        $ git merge topic

              o\-\-\-*\-\-\-o\-\-\-+\-\-\-o\-\-\-o topic
             /           /         \e
    o\-\-\-o\-\-\-o\-\-\-*\-\-\-o\-\-\-o\-\-\-o\-\-\-o\-\-\-+ master
\.ft

.fi
.RE
When your topic branch is long\-lived, however, your topic branch would end up having many such "Merge from master" commits on it, which would unnecessarily clutter the development history\. Readers of the Linux kernel mailing list may remember that Linus complained about such too frequent test merges when a subsystem maintainer asked to pull from a branch full of "useless merges"\.

As an alternative, to keep the topic branch clean of test merges, you could blow away the test merge, and keep building on top of the tip before the test merge:

.sp
.RS 4
.nf

\.ft C
        $ git checkout topic
        $ git merge master
        $ git reset \-\-hard HEAD^ ;# rewind the test merge
        $ \.\.\. work on both topic and master branches
        $ git checkout master
        $ git merge topic

              o\-\-\-*\-\-\-o\-\-\-\-\-\-\-o\-\-\-o topic
             /                     \e
    o\-\-\-o\-\-\-o\-\-\-*\-\-\-o\-\-\-o\-\-\-o\-\-\-o\-\-\-+ master
\.ft

.fi
.RE
This would leave only one merge commit when your topic branch is finally ready and merged into the master branch\. This merge would require you to resolve the conflict, introduced by the commits marked with *\. However, often this conflict is the same conflict you resolved when you created the test merge you blew away\. \fIgit\-rerere\fR command helps you to resolve this final conflicted merge using the information from your earlier hand resolve\.

Running the \fIgit\-rerere\fR command immediately after a conflicted automerge records the conflicted working tree files, with the usual conflict markers <<<<<<<, =======, and >>>>>>> in them\. Later, after you are done resolving the conflicts, running \fIgit\-rerere\fR again records the resolved state of these files\. Suppose you did this when you created the test merge of master into the topic branch\.

Next time, running \fIgit\-rerere\fR after seeing a conflicted automerge, if the conflict is the same as the earlier one recorded, it is noticed and a three\-way merge between the earlier conflicted automerge, the earlier manual resolution, and the current conflicted automerge is performed by the command\. If this three\-way merge resolves cleanly, the result is written out to your working tree file, so you would not have to manually resolve it\. Note that \fIgit\-rerere\fR leaves the index file alone, so you still need to do the final sanity checks with git diff (or git diff \-c) and \fIgit\-add\fR when you are satisfied\.

As a convenience measure, \fIgit\-merge\fR automatically invokes \fIgit\-rerere\fR when it exits with a failed automerge, which records it if it is a new conflict, or reuses the earlier hand resolve when it is not\. \fIgit\-commit\fR also invokes \fIgit\-rerere\fR when recording a merge result\. What this means is that you do not have to do anything special yourself (Note: you still have to set the config variable rerere\.enabled to enable this command)\.

In our example, when you did the test merge, the manual resolution is recorded, and it will be reused when you do the actual merge later with updated master and topic branch, as long as the earlier resolution is still applicable\.

The information \fIgit\-rerere\fR records is also used when running \fIgit\-rebase\fR\. After blowing away the test merge and continuing development on the topic branch:

.sp
.RS 4
.nf

\.ft C
              o\-\-\-*\-\-\-o\-\-\-\-\-\-\-o\-\-\-o topic
             /
    o\-\-\-o\-\-\-o\-\-\-*\-\-\-o\-\-\-o\-\-\-o\-\-\-o   master

        $ git rebase master topic

                                  o\-\-\-*\-\-\-o\-\-\-\-\-\-\-o\-\-\-o topic
                                 /
    o\-\-\-o\-\-\-o\-\-\-*\-\-\-o\-\-\-o\-\-\-o\-\-\-o   master
\.ft

.fi
.RE
you could run git rebase master topic, to keep yourself up\-to\-date even before your topic is ready to be sent upstream\. This would result in falling back to three\-way merge, and it would conflict the same way the test merge you resolved earlier\. \fIgit\-rerere\fR is run by \fIgit\-rebase\fR to help you resolve this conflict\.
.SH "AUTHOR"
Written by Junio C Hamano <gitster@pobox\.com>
.SH "GIT"
Part of the \fBgit\fR(1) suite

