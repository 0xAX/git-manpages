.\" ** You probably do not want to edit this file directly **
.\" It was generated using the DocBook XSL Stylesheets (version 1.69.1).
.\" Instead of manually editing it, you probably should edit the DocBook XML
.\" source for it and then use the DocBook XSL Stylesheets to regenerate it.
.TH "GIT\-MERGE" "1" "02/13/2007" "" ""
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.SH "NAME"
git\-merge \- Join two or more development histories together
.SH "SYNOPSIS"
.sp
.nf
\fIgit\-merge\fR [\-n] [\-\-no\-commit] [\-\-squash] [\-s <strategy>]\&...
        [\-m <msg>] <remote> <remote>\&...
.fi
.SH "DESCRIPTION"
This is the top\-level interface to the merge machinery which drives multiple merge strategy scripts.
.SH "OPTIONS"
.TP
\-n, \-\-no\-summary
Do not show diffstat at the end of the merge.
.TP
\-\-no\-commit
Perform the merge but pretend the merge failed and do not autocommit, to give the user a chance to inspect and further tweak the merge result before committing.
.TP
\-\-squash
Produce the working tree and index state as if a real merge happened, but do not actually make a commit or move the HEAD, nor record $GIT_DIR/MERGE_HEAD to cause the next git commit command to create a merge commit. This allows you to create a single commit on top of the current branch whose effect is the same as merging another branch (or more in case of an octopus).
.TP
\-s <strategy>, \-\-strategy=<strategy>
Use the given merge strategy; can be supplied more than once to specify them in the order they should be tried. If there is no \-s option, a built\-in list of strategies is used instead (git\-merge\-recursive when merging a single head, git\-merge\-octopus otherwise).
.TP
<msg>
The commit message to be used for the merge commit (in case it is created). The git\-fmt\-merge\-msg script can be used to give a good default for automated git\-merge invocations.
.TP
<head>
Our branch head commit. This has to be HEAD, so new syntax does not require it
.TP
<remote>
Other branch head merged into our branch. You need at least one <remote>. Specifying more than one <remote> obviously means you are trying an Octopus.
.SH "MERGE STRATEGIES"
.TP
resolve
This can only resolve two heads (i.e. the current branch and another branch you pulled from) using 3\-way merge algorithm. It tries to carefully detect criss\-cross merge ambiguities and is considered generally safe and fast.
.TP
recursive
This can only resolve two heads using 3\-way merge algorithm. When there are more than one common ancestors that can be used for 3\-way merge, it creates a merged tree of the common ancestors and uses that as the reference tree for the 3\-way merge. This has been reported to result in fewer merge conflicts without causing mis\-merges by tests done on actual merge commits taken from Linux 2.6 kernel development history. Additionally this can detect and handle merges involving renames. This is the default merge strategy when pulling or merging one branch.
.TP
octopus
This resolves more than two\-head case, but refuses to do complex merge that needs manual resolution. It is primarily meant to be used for bundling topic branch heads together. This is the default merge strategy when pulling or merging more than one branches.
.TP
ours
This resolves any number of heads, but the result of the merge is always the current branch head. It is meant to be used to supersede old development history of side branches.

If you tried a merge which resulted in a complex conflicts and would want to start over, you can recover with \fBgit\-reset\fR(1).
.SH "HOW MERGE WORKS"
A merge is always between the current HEAD and one or more remote branch heads, and the index file must exactly match the tree of HEAD commit (i.e. the contents of the last commit) when it happens. In other words, git\-diff \-\-cached HEAD must report no changes.
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
\fBNote\fR
This is a bit of lie. In certain special cases, your index are allowed to be different from the tree of HEAD commit. The most notable case is when your HEAD commit is already ahead of what is being merged, in which case your index can have arbitrary difference from your HEAD commit. Otherwise, your index entries are allowed have differences from your HEAD commit that match the result of trivial merge (e.g. you received the same patch from external source to produce the same result as what you are merging). For example, if a path did not exist in the common ancestor and your head commit but exists in the tree you are merging into your repository, and if you already happen to have that path exactly in your index, the merge does not have to fail.

Otherwise, merge will refuse to do any harm to your repository (that is, it may fetch the objects from remote, and it may even update the local branch used to keep track of the remote branch with git pull remote rbranch:lbranch, but your working tree, .git/HEAD pointer and index file are left intact).

You may have local modifications in the working tree files. In other words, git\-diff is allowed to report changes. However, the merge uses your working tree as the working area, and in order to prevent the merge operation from losing such changes, it makes sure that they do not interfere with the merge. Those complex tables in read\-tree documentation define what it means for a path to "interfere with the merge". And if your local modifications interfere with the merge, again, it stops before touching anything.

So in the above two "failed merge" case, you do not have to worry about loss of data \-\-\- you simply were not ready to do a merge, so no merge happened at all. You may want to finish whatever you were in the middle of doing, and retry the same pull after you are done and ready.

When things cleanly merge, these things happen:
.TP 3
1.
the results are updated both in the index file and in your working tree,
.TP
2.
index file is written out as a tree,
.TP
3.
the tree gets committed, and
.TP
4.
the HEAD pointer gets advanced.

Because of 2., we require that the original state of the index file to match exactly the current HEAD commit; otherwise we will write out your local changes already registered in your index file along with the merge result, which is not good. Because 1. involves only the paths different between your branch and the remote branch you are pulling from during the merge (which is typically a fraction of the whole tree), you can have local modifications in your working tree as long as they do not overlap with what the merge updates.

When there are conflicts, these things happen:
.TP 3
1.
HEAD stays the same.
.TP
2.
Cleanly merged paths are updated both in the index file and in your working tree.
.TP
3.
For conflicting paths, the index file records up to three versions; stage1 stores the version from the common ancestor, stage2 from HEAD, and stage3 from the remote branch (you can inspect the stages with git\-ls\-files \-u). The working tree files have the result of "merge" program; i.e. 3\-way merge result with familiar conflict markers <<< === >>>.
.TP
4.
No other changes are done. In particular, the local modifications you had before you started merge will stay the same and the index entries for them stay as they were, i.e. matching HEAD.

After seeing a conflict, you can do two things:
.TP 3
\(bu
Decide not to merge. The only clean\-up you need are to reset the index file to the HEAD commit to reverse 2. and to clean up working tree changes made by 2. and 3.; git\-reset can be used for this.
.TP
\(bu
Resolve the conflicts. git\-diff would report only the conflicting paths because of the above 2. and 3.. Edit the working tree files into a desirable shape, git\-update\-index them, to make the index file contain what the merge result should be, and run git\-commit to commit the result.
.SH "SEE ALSO"
\fBgit\-fmt\-merge\-msg\fR(1), \fBgit\-pull\fR(1)
.SH "AUTHOR"
Written by Junio C Hamano <junkio@cox.net>
.SH "DOCUMENTATION"
Documentation by Junio C Hamano and the git\-list <git@vger.kernel.org>.
.SH "GIT"
Part of the \fBgit\fR(7) suite

