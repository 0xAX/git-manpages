.\"     Title: git-merge
.\"    Author: 
.\" Generator: DocBook XSL Stylesheets v1.73.2 <http://docbook.sf.net/>
.\"      Date: 07/15/2008
.\"    Manual: Git Manual
.\"    Source: Git 1.5.6.3.350.g6c11a
.\"
.TH "GIT\-MERGE" "1" "07/15/2008" "Git 1\.5\.6\.3\.350\.g6c11a" "Git Manual"
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.SH "NAME"
git-merge - Join two or more development histories together
.SH "SYNOPSIS"
.sp
.RS 4
.nf
\fIgit merge\fR [\-n] [\-\-stat] [\-\-no\-commit] [\-\-squash] [\-s <strategy>]\&...
        [\-m <msg>] <remote> <remote>\&...
\fIgit merge\fR <msg> HEAD <remote>\&...
.fi
.RE
.SH "DESCRIPTION"
This is the top\-level interface to the merge machinery which drives multiple merge strategy scripts\.

The second syntax (<msg> HEAD <remote>) is supported for historical reasons\. Do not use it from the command line or in new scripts\. It is the same as git merge \-m <msg> <remote>\.
.SH "OPTIONS"
.PP
\-\-stat
.RS 4
Show a diffstat at the end of the merge\. The diffstat is also controlled by the configuration option merge\.stat\.
.RE
.PP
\-n, \-\-no\-stat
.RS 4
Do not show diffstat at the end of the merge\.
.RE
.PP
\-\-summary, \-\-no\-summary
.RS 4
Synonyms to \-\-stat and \-\-no\-stat; these are deprecated and will be removed in the future\.
.RE
.PP
\-\-log
.RS 4
In addition to branch names, populate the log message with one\-line descriptions from the actual commits that are being merged\.
.RE
.PP
\-\-no\-log
.RS 4
Do not list one\-line descriptions from the actual commits being merged\.
.RE
.PP
\-\-no\-commit
.RS 4
Perform the merge but pretend the merge failed and do not autocommit, to give the user a chance to inspect and further tweak the merge result before committing\.
.RE
.PP
\-\-commit
.RS 4
Perform the merge and commit the result\. This option can be used to override \-\-no\-commit\.
.RE
.PP
\-\-squash
.RS 4
Produce the working tree and index state as if a real merge happened, but do not actually make a commit or move the HEAD, nor record $GIT_DIR/MERGE_HEAD to cause the next git commit command to create a merge commit\. This allows you to create a single commit on top of the current branch whose effect is the same as merging another branch (or more in case of an octopus)\.
.RE
.PP
\-\-no\-squash
.RS 4
Perform the merge and commit the result\. This option can be used to override \-\-squash\.
.RE
.PP
\-\-no\-ff
.RS 4
Generate a merge commit even if the merge resolved as a fast\-forward\.
.RE
.PP
\-\-ff
.RS 4
Do not generate a merge commit if the merge resolved as a fast\-forward, only update the branch pointer\. This is the default behavior of git\-merge\.
.RE
.PP
\-s <strategy>, \-\-strategy=<strategy>
.RS 4
Use the given merge strategy; can be supplied more than once to specify them in the order they should be tried\. If there is no \-s option, a built\-in list of strategies is used instead (\fIgit\-merge\-recursive\fR when merging a single head, \fIgit\-merge\-octopus\fR otherwise)\.
.RE
.PP
\-m <msg>
.RS 4
The commit message to be used for the merge commit (in case it is created)\. The \fIgit\-fmt\-merge\-msg\fR script can be used to give a good default for automated \fIgit\-merge\fR invocations\.
.RE
.PP
<remote>
.RS 4
Other branch head merged into our branch\. You need at least one <remote>\. Specifying more than one <remote> obviously means you are trying an Octopus\.
.RE
.SH "MERGE STRATEGIES"
.PP
resolve
.RS 4
This can only resolve two heads (i\.e\. the current branch and another branch you pulled from) using 3\-way merge algorithm\. It tries to carefully detect criss\-cross merge ambiguities and is considered generally safe and fast\.
.RE
.PP
recursive
.RS 4
This can only resolve two heads using 3\-way merge algorithm\. When there are more than one common ancestors that can be used for 3\-way merge, it creates a merged tree of the common ancestors and uses that as the reference tree for the 3\-way merge\. This has been reported to result in fewer merge conflicts without causing mis\-merges by tests done on actual merge commits taken from Linux 2\.6 kernel development history\. Additionally this can detect and handle merges involving renames\. This is the default merge strategy when pulling or merging one branch\.
.RE
.PP
octopus
.RS 4
This resolves more than two\-head case, but refuses to do complex merge that needs manual resolution\. It is primarily meant to be used for bundling topic branch heads together\. This is the default merge strategy when pulling or merging more than one branches\.
.RE
.PP
ours
.RS 4
This resolves any number of heads, but the result of the merge is always the current branch head\. It is meant to be used to supersede old development history of side branches\.
.RE
.PP
subtree
.RS 4
This is a modified recursive strategy\. When merging trees A and B, if B corresponds to a subtree of A, B is first adjusted to match the tree structure of A, instead of reading the trees at the same level\. This adjustment is also done to the common ancestor tree\.
.RE
If you tried a merge which resulted in a complex conflicts and would want to start over, you can recover with \fIgit\-reset\fR\.
.SH "CONFIGURATION"
.PP
merge\.stat
.RS 4
Whether to print the diffstat berween ORIG_HEAD and merge result at the end of the merge\. True by default\.
.RE
.PP
merge\.log
.RS 4
Whether to include summaries of merged commits in newly created merge commit messages\. False by default\.
.RE
.PP
merge\.renameLimit
.RS 4
The number of files to consider when performing rename detection during a merge; if not specified, defaults to the value of diff\.renameLimit\.
.RE
.PP
merge\.tool
.RS 4
Controls which merge resolution program is used by \fBgit-mergetool\fR(1)\. Valid built\-in values are: "kdiff3", "tkdiff", "meld", "xxdiff", "emerge", "vimdiff", "gvimdiff", and "opendiff"\. Any other value is treated is custom merge tool and there must be a corresponing mergetool\.<tool>\.cmd option\.
.RE
.PP
merge\.verbosity
.RS 4
Controls the amount of output shown by the recursive merge strategy\. Level 0 outputs nothing except a final error message if conflicts were detected\. Level 1 outputs only conflicts, 2 outputs conflicts and file changes\. Level 5 and above outputs debugging information\. The default is level 2\. Can be overridden by \fIGIT_MERGE_VERBOSITY\fR environment variable\.
.RE
.PP
merge\.<driver>\.name
.RS 4
Defines a human readable name for a custom low\-level merge driver\. See \fBgitattributes\fR(5) for details\.
.RE
.PP
merge\.<driver>\.driver
.RS 4
Defines the command that implements a custom low\-level merge driver\. See \fBgitattributes\fR(5) for details\.
.RE
.PP
merge\.<driver>\.recursive
.RS 4
Names a low\-level merge driver to be used when performing an internal merge between common ancestors\. See \fBgitattributes\fR(5) for details\.
.RE
.PP
branch\.<name>\.mergeoptions
.RS 4
Sets default options for merging into branch <name>\. The syntax and supported options are equal to that of \fIgit\-merge\fR, but option values containing whitespace characters are currently not supported\.
.RE
.SH "HOW MERGE WORKS"
A merge is always between the current HEAD and one or more commits (usually, branch head or tag), and the index file must exactly match the tree of HEAD commit (i\.e\. the contents of the last commit) when it happens\. In other words, git diff \-\-cached HEAD must report no changes\.
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
Note
This is a bit of a lie\. In certain special cases, your index is allowed to be different from the tree of the HEAD commit\. The most notable case is when your HEAD commit is already ahead of what is being merged, in which case your index can have arbitrary differences from your HEAD commit\. Also, your index entries may have differences from your HEAD commit that match the result of a trivial merge (e\.g\. you received the same patch from an external source to produce the same result as what you are merging)\. For example, if a path did not exist in the common ancestor and your head commit but exists in the tree you are merging into your repository, and if you already happen to have that path exactly in your index, the merge does not have to fail\.


Otherwise, merge will refuse to do any harm to your repository (that is, it may fetch the objects from remote, and it may even update the local branch used to keep track of the remote branch with git pull remote rbranch:lbranch, but your working tree, \.git/HEAD pointer and index file are left intact)\. In addition, merge always sets \.git/ORIG_HEAD to the original state of HEAD so a problematic merge can be removed by using git reset ORIG_HEAD\.

You may have local modifications in the working tree files\. In other words, \fIgit\-diff\fR is allowed to report changes\. However, the merge uses your working tree as the working area, and in order to prevent the merge operation from losing such changes, it makes sure that they do not interfere with the merge\. Those complex tables in read\-tree documentation define what it means for a path to "interfere with the merge"\. And if your local modifications interfere with the merge, again, it stops before touching anything\.

So in the above two "failed merge" case, you do not have to worry about loss of data \-\-\- you simply were not ready to do a merge, so no merge happened at all\. You may want to finish whatever you were in the middle of doing, and retry the same pull after you are done and ready\.

When things cleanly merge, these things happen:

.sp
.RS 4
\h'-04' 1.\h'+02'The results are updated both in the index file and in your working tree;
.RE
.sp
.RS 4
\h'-04' 2.\h'+02'Index file is written out as a tree;
.RE
.sp
.RS 4
\h'-04' 3.\h'+02'The tree gets committed; and
.RE
.sp
.RS 4
\h'-04' 4.\h'+02'The HEAD pointer gets advanced\.
.RE
Because of 2\., we require that the original state of the index file to match exactly the current HEAD commit; otherwise we will write out your local changes already registered in your index file along with the merge result, which is not good\. Because 1\. involves only the paths different between your branch and the remote branch you are pulling from during the merge (which is typically a fraction of the whole tree), you can have local modifications in your working tree as long as they do not overlap with what the merge updates\.

When there are conflicts, these things happen:

.sp
.RS 4
\h'-04' 1.\h'+02'HEAD stays the same\.
.RE
.sp
.RS 4
\h'-04' 2.\h'+02'Cleanly merged paths are updated both in the index file and in your working tree\.
.RE
.sp
.RS 4
\h'-04' 3.\h'+02'For conflicting paths, the index file records up to three versions; stage1 stores the version from the common ancestor, stage2 from HEAD, and stage3 from the remote branch (you can inspect the stages with git ls\-files \-u)\. The working tree files have the result of "merge" program; i\.e\. 3\-way merge result with familiar conflict markers <<< === >>>\.
.RE
.sp
.RS 4
\h'-04' 4.\h'+02'No other changes are done\. In particular, the local modifications you had before you started merge will stay the same and the index entries for them stay as they were, i\.e\. matching HEAD\.
.RE
After seeing a conflict, you can do two things:

.sp
.RS 4
\h'-04'\(bu\h'+03'Decide not to merge\. The only clean\-up you need are to reset the index file to the HEAD commit to reverse 2\. and to clean up working tree changes made by 2\. and 3\.; \fIgit\-reset\fR can be used for this\.
.RE
.sp
.RS 4
\h'-04'\(bu\h'+03'Resolve the conflicts\. git diff would report only the conflicting paths because of the above 2\. and 3\. Edit the working tree files into a desirable shape, \fIgit\-add\fR or \fIgit\-rm\fR them, to make the index file contain what the merge result should be, and run \fIgit\-commit\fR to commit the result\.
.RE
.SH "SEE ALSO"
\fBgit-fmt-merge-msg\fR(1), \fBgit-pull\fR(1), \fBgitattributes\fR(5), \fBgit-reset\fR(1), \fBgit-diff\fR(1), \fBgit-ls-files\fR(1), \fBgit-add\fR(1), \fBgit-rm\fR(1), \fBgit-mergetool\fR(1)
.SH "AUTHOR"
Written by Junio C Hamano <junkio@cox\.net>
.SH "DOCUMENTATION"
Documentation by Junio C Hamano and the git\-list <git@vger\.kernel\.org>\.
.SH "GIT"
Part of the \fBgit\fR(1) suite

