.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "GIT-BISECT" 1 "" "" ""
.SH NAME
git-bisect \- Find the change that introduced a bug
.SH "SYNOPSIS"


git bisect <subcommand> <options>

.SH "DESCRIPTION"


The command takes various subcommands, and different options depending on the subcommand:

.nf
git bisect start [<paths>\&.\&.\&.]
git bisect bad <rev>
git bisect good <rev>
git bisect reset [<branch>]
git bisect visualize
git bisect replay <logfile>
git bisect log
.fi


This command uses git\-rev\-list \-\-bisect option to help drive the binary search process to find which change introduced a bug, given an old "good" commit object name and a later "bad" commit object name\&.


The way you use it is:

.IP
$ git bisect start
$ git bisect bad                        # Current version is bad
$ git bisect good v2\&.6\&.13\-rc2           # v2\&.6\&.13\-rc2 was the last version
                                        # tested that was good

When you give at least one bad and one good versions, it will bisect the revision tree and say something like:

.IP
Bisecting: 675 revisions left to test after this

and check out the state in the middle\&. Now, compile that kernel, and boot it\&. Now, let's say that this booted kernel works fine, then just do

.IP
$ git bisect good                       # this one is good

which will now say

.IP
Bisecting: 337 revisions left to test after this

and you continue along, compiling that one, testing it, and depending on whether it is good or bad, you say "git bisect good" or "git bisect bad", and ask for the next bisection\&.


Until you have no more left, and you'll have been left with the first bad kernel rev in "refs/bisect/bad"\&.


Oh, and then after you want to reset to the original head, do a

.IP
$ git bisect reset

to get back to the master branch, instead of being in one of the bisection branches ("git bisect start" will do that for you too, actually: it will reset the bisection state, and before it does that it checks that you're not using some old bisection branch)\&.


During the bisection process, you can say

.IP
$ git bisect visualize

to see the currently remaining suspects in gitk\&.


The good/bad input is logged, and git bisect log shows what you have done so far\&. You can truncate its output somewhere and save it in a file, and run

.IP
$ git bisect replay that\-file

if you find later you made a mistake telling good/bad about a revision\&.


If in a middle of bisect session, you know what the bisect suggested to try next is not a good one to test (e\&.g\&. the change the commit introduces is known not to work in your environment and you know it does not have anything to do with the bug you are chasing), you may want to find a near\-by commit and try that instead\&. It goes something like this:

.IP
$ git bisect good/bad                   # previous round was good/bad\&.
Bisecting: 337 revisions left to test after this
$ git bisect visualize                  # oops, that is uninteresting\&.
$ git reset \-\-hard HEAD~3               # try 3 revs before what
                                        # was suggested

Then compile and test the one you chose to try\&. After that, tell bisect what the result was as usual\&.


You can further cut down the number of trials if you know what part of the tree is involved in the problem you are tracking down, by giving paths parameters when you say bisect start, like this:

.IP
$ git bisect start arch/i386 include/asm\-i386
.SH "AUTHOR"


Written by Linus Torvalds <torvalds@osdl\&.org>

.SH "DOCUMENTATION"


Documentation by Junio C Hamano and the git\-list <git@vger\&.kernel\&.org>\&.

.SH "GIT"


Part of the \fBgit\fR(7) suite

